using System.Collections.Generic;
using FluentAssertions;
using LeetCode.Exercises.Queues;
using Xunit;

namespace LeetCode.Exercises.Tests
{
    public class IslandTests
    {
        public static IEnumerable<object[]> ArrayData
        {
            get
            {
                return new[]
                {
                    new object[]
                    {
                        new char[,]
                        {
                            {'1', '1', '0', '0', '1', '0'},
                            {'1', '0', '1', '0', '1', '0'},
                            {'0', '0', '1', '0', '0', '1'},
                            {'0', '1', '1', '1', '0', '0'},
                            {'0', '0', '0', '1', '0', '0'},
                            {'1', '1', '1', '1', '0', '0'}
                        },
                        4
                    },
                    new object[]
                    {
                        new char[,]
                        {
                             {'1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','0','1','0','1','1'},
                             {'0','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','0'},
                             {'1','0','1','1','1','0','0','1','1','0','1','1','1','1','1','1','1','1','1','1'},
                             {'1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},
                             {'1','0','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},
                             {'1','0','1','1','1','1','1','1','0','1','1','1','0','1','1','1','0','1','1','1'},
                             {'0','1','1','1','1','1','1','1','1','1','1','1','0','1','1','0','1','1','1','1'},
                             {'1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','0','1','1'},
                             {'1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1'},
                             {'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},
                             {'0','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1'},
                             {'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},
                             {'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},
                             {'1','1','1','1','1','0','1','1','1','1','1','1','1','0','1','1','1','1','1','1'},
                             {'1','0','1','1','1','1','1','0','1','1','1','0','1','1','1','1','0','1','1','1'},
                             {'1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','0'},
                             {'1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','0','0'},
                             {'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},
                             {'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},
                             {'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'}
                        },
                        1
                    }
                };
            }
        }

        [Theory]
        [MemberData(nameof(ArrayData))]
        public void TestSolution(char[,] grid, int expectedNumber)
        {
            var solution = new NumberOfIslands();

            var actualNumber = solution.NumIslands(grid);
            actualNumber.Should().Be(expectedNumber);
        }
        
    }
}